<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SilentSpeechCoder</title>
  
  <subtitle>SilentSpeechCoder</subtitle>
  <link href="https://silentspeechcoder.github.io/atom.xml" rel="self"/>
  
  <link href="https://silentspeechcoder.github.io/"/>
  <updated>2022-07-21T04:46:44.658Z</updated>
  <id>https://silentspeechcoder.github.io/</id>
  
  <author>
    <name>Yangzk</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://silentspeechcoder.github.io/2022/07/21/fan-she-fan-xu-lie-hua/"/>
    <id>https://silentspeechcoder.github.io/2022/07/21/fan-she-fan-xu-lie-hua/</id>
    <published>2022-07-21T04:46:44.658Z</published>
    <updated>2022-07-21T04:46:44.658Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式（Group Of Four 23）【待补充】</title>
    <link href="https://silentspeechcoder.github.io/2021/10/12/java-she-ji-mo-shi/"/>
    <id>https://silentspeechcoder.github.io/2021/10/12/java-she-ji-mo-shi/</id>
    <published>2021-10-12T08:24:43.000Z</published>
    <updated>2022-07-27T12:37:40.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式（Group-Of-Four-23）【待补充】"><a href="#设计模式（Group-Of-Four-23）【待补充】" class="headerlink" title="设计模式（Group Of Four 23）【待补充】"></a>设计模式（Group Of Four 23）【待补充】</h1><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul><li><p>创建者模式</p><p>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式</p></li><li><p>结构型模式</p><p>适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式</p></li><li><p>行为型模式</p><p>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式</p></li></ul><h2 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h2><h3 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 - Singleton"></a>单例模式 - Singleton</h3><ol><li><p>作用：保证一个类只有一个实例对象，并且提供一个访问该实例的全局访问点（方法）</p></li><li><p>应用场景：Spring中的每个bean；数据库连接池的设计；windows任务管理器；Windows回收站</p></li><li><p>优点：</p><ul><li><p>只生成一个实例，减少了系统性能开销。当一个对象的产生需要比较多的资源时，则在应用启动时产生一个单例对象，然后永久存在内存中</p></li><li><p>在系统设置全局访问点，优化环共享资源访问</p></li></ul></li><li><p>常见的实现方式</p><ul><li><p>饿汉式（线程安全、调用效率高。但是，不能延时加载）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    饿汉式单例实现：    1. 私有化构造器    2. 提供一个私有的static变量，存放唯一对象    3. 提供开放的方法访问对象* *&#x2F;public class SingletonDemo1 &#123;    &#x2F;&#x2F; 类初始化时。立即加载这个对象。存在问题：如果不调用getInstance()则会造成资源浪费    private static &#x2F;*final*&#x2F; SingletonDemo1 instance &#x3D; new SingletonDemo1();    private SingletonDemo1()&#123;    &#125;    &#x2F;&#x2F; static变量在类加载时初始化,不会发生并发访问的问题    public static &#x2F;*synchronized*&#x2F; SingletonDemo1 getInstance()&#123;        return instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>懒汉式（线程安全、调用效率不高。但是，能延时加载）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    懒汉式单例实现：    1. 提供一个私有的不初始化static变量，    2. 私有化构造器    3. 调用getInstance时new一个对象* *&#x2F;public class SingletonDemo2 &#123;    &#x2F;&#x2F; 延迟加载    private static SingletonDemo2 instance;    private SingletonDemo2()&#123;    &#125;    &#x2F;&#x2F;每次调用getInstance()都要同步，并发效率低    public static synchronized SingletonDemo2 getInstance()&#123;        if(instance &#x3D;&#x3D; null)&#123;            instance &#x3D; new SingletonDemo2();        &#125;        return instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双重检测锁式（JVM底层内部的原因，不建议使用）</p></li><li><p>静态内部类式（线程安全、调用效率高。能延时加载）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    静态内部类单例实现：    1. 私有化构造器    2. 创建静态内部类，在其中提供一个私有的static变量，存放唯一对象    3. 提供开放的方法访问对象* *&#x2F;public class SingletonDemo3 &#123;    &#x2F;&#x2F; 外部类没有static属性，则不会立即加载对象，也不会加载静态内部类    private static class SingletonClassInstance&#123;        &#x2F;&#x2F; 调用时加载静态内部类，加载类时天然线程安全。instance是static final修饰，保证内存中只有一个实例存在并且不能被修改        private static final SingletonDemo3 instance &#x3D; new SingletonDemo3();    &#125;    private SingletonDemo3()&#123;    &#125;    public static SingletonDemo3 getInstance()&#123;        return SingletonClassInstance.instance;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>枚举单例（线程安全、调用效率高。但是，不能延时加载。避免通过反射和序列化产生的漏洞）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*    枚举式单例实现：    1. 定义一个枚举的元素* *&#x2F;public enum SingletonDemo4 &#123;    &#x2F;&#x2F; 枚举类即单例模式。定义一个枚举的元素，代表一个实例    INSTANCE;    public void singletonOperation()&#123;        &#x2F;&#x2F; 对实例的操作    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>选用</p><p>单例对象 占用资源少，不需要延时加载：枚举式好于饿汉式</p><p>单例对象 占用资源大，需要延时加载：静态内部类式好于懒汉式</p></li><li><p>反射反序列化测试单例漏洞（枚举类型除外）</p><ul><li><p>反射</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Class&lt;SingletonDemo1&gt; clazz &#x3D; (Class&lt;SingletonDemo1&gt;) Class.forName(&quot;SingletonDemo.ehan.SingletonDemo1&quot;);Constructor&lt;SingletonDemo1&gt; c &#x3D; clazz.getDeclaredConstructor(null);c.setAccessible(true);SingletonDemo1 a &#x3D;c.newInstance();SingletonDemo1 b &#x3D;c.newInstance();System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false,两个不同的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  解决：私有化构造器加入异常判断</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">private SingletonDemo1()&#123;    if(instance !&#x3D; null)&#123;        throw new RuntimeException();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>反序列化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; SingletonDemo1需要实现SerializableSingletonDemo1 a &#x3D; SingletonDemo1.getInstance();&#x2F;&#x2F; 序列化FileOutputStream fos &#x3D; new FileOutputStream(&quot;d:&#x2F;a.txt&quot;);ObjectOutputStream oos &#x3D; new ObjectOutputStream(fos);oos.writeObject(a);oos.close();fos.close();&#x2F;&#x2F; 反序列化ObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;d:&#x2F;a.txt&quot;));SingletonDemo1 b &#x3D; (SingletonDemo1)ois.readObject();System.out.println(a &#x3D;&#x3D; b); &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决：添加readResolve方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 反序列化时，返回单例对象private Object readResolve() throws ObjectStreamException&#123;return instance;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h3 id="工厂模式-Factory"><a href="#工厂模式-Factory" class="headerlink" title="工厂模式 - Factory"></a>工厂模式 - Factory</h3><ol><li><p>作用：实现了创建者和调用者的分离</p></li><li><p>面向对象设计的基本原则：</p><ul><li>OCP开闭原则（open-closed principle）：一个软件的实体应该对扩展开放，对修改关闭</li><li>DIP依赖倒转原则（dependence inversionprinciple）：针对接口编程，不要针对实现编程</li><li>LOD迪米特原则（Law of Demeter）：只与你直接的朋友通信，而避免与陌生人通信</li></ul></li><li><p>应用场景：Calender的getInstance方法；JDBC中connection对象的获取</p></li><li><p>实现方式</p><ul><li><p>简单工厂模式（静态工厂模式）</p><p>描述：工厂类一般使用静态方法，通过接收的参数不同来返回不同的对象实例</p><p>问题：对于增加新产品，不修改代码的话无法扩展（不满足OCP）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class TestObjectSimpleFactory &#123;    public static TestObject createTestObject(String type)&#123;        if(type.equals(&quot;one&quot;))&#123;            return new ChildObjectOne();        &#125; else if(type.equals(&quot;two&quot;)) &#123;            return new ChildObjectTwo();        &#125;        return null;    &#125;&#125;public class client &#123;    public static void main(String[] args) &#123;        TestObject a &#x3D; TestObjectSimpleFactory.createTestObject(&quot;one&quot;);        TestObject b &#x3D; TestObjectSimpleFactory.createTestObject(&quot;two&quot;);        a.run();        b.run();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>工厂方法模式</p><p>描述：简单工厂模式只有一个工厂类，工厂方法模式有一组实现了相同接口的工厂类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface TestObjectMethodFactory &#123;    TestObject createTestObject();&#125;public class ChildObjectOneFactory implements TestObjectMethodFactory &#123;    @Override    public TestObject createTestObject  () &#123;        return new ChildObjectOne();    &#125;&#125;public class ChildObjectTwoFactory implements TestObjectMethodFactory &#123;    @Override    public TestObject createTestObject  () &#123;        return new ChildObjectTwo();    &#125;&#125;public static void main(String[] args) &#123;    TestObject a &#x3D; new ChildObjectOneFactory().createTestObject();    TestObject b &#x3D; new ChildObjectTwoFactory().createTestObject();    a.run();    b.run();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>抽象工厂模式</p><p>描述：用来生产不同产品族的全部产品。是工厂方法模式的升级版本。提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>问题：对于增加新的产品，无能为力。支持增加产品族</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface TestObjectOne &#123;    public void runOne();    public void runTwo();&#125;public class TestObjectOneHigher implements TestObjectOne &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectOneHigher runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectOneHigher runTwo&quot;);    &#125;&#125;public class TestObjectOneLower implements TestObjectOne &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectOneLower runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectOneLower runTwo&quot;);    &#125;&#125;public interface TestObjectTwo &#123;    public void runOne();    public void runTwo();&#125;public class TestObjectTwoHigher implements TestObjectTwo &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectTwoHigher runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectTwoHigher runTwo&quot;);    &#125;&#125;public class TestObjectTwoLower implements TestObjectTwo &#123;    @Override    public void runOne() &#123;        System.out.println(&quot;TestObjectTwo runOne&quot;);    &#125;    @Override    public void runTwo() &#123;        System.out.println(&quot;TestObjectTwo runTwo&quot;);    &#125;&#125;public interface TestAbstractFactory &#123;    TestObjectOne createTestObjectOne();    TestObjectTwo createTestObjectTwo();&#125;public class TestHigherFactory implements TestAbstractFactory &#123;    @Override    public TestObjectOne createTestObjectOne() &#123;        return new TestObjectOneHigher();    &#125;    @Override    public TestObjectTwo createTestObjectTwo() &#123;        return new TestObjectTwoHigher();    &#125;&#125;public class TestLowerFactory implements TestAbstractFactory&#123;    @Override    public TestObjectOne createTestObjectOne() &#123;        return new TestObjectOneLower();    &#125;    @Override    public TestObjectTwo createTestObjectTwo() &#123;        return new TestObjectTwoLower();    &#125;&#125;public class client &#123;    public static void main(String[] args) &#123;        TestAbstractFactory lowerFactory &#x3D; new TestLowerFactory();        TestAbstractFactory higherFactory &#x3D; new TestHigherFactory();        TestObjectOne a &#x3D; lowerFactory.createTestObjectOne();        TestObjectOne b &#x3D; higherFactory.createTestObjectOne();        a.runOne();        a.runTwo();        b.runOne();        b.runTwo();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>比较：</p><p>简单工厂模式：结构复杂度更低</p><p>工厂方法模式：代码复杂度更低</p><p>设计理论工厂方法模式更优，但一般选择简单工厂模式</p></li></ol><h3 id="建造者模式-Builder"><a href="#建造者模式-Builder" class="headerlink" title="建造者模式 - Builder"></a>建造者模式 - Builder</h3><ol><li><p>作用：实现了构建（Builder）和装配（Director）的解耦，从而构造出复杂的对象。实现了构建算法、装配算法的解耦，实现更好的复用。</p></li><li><p>应用场景：StringBuilder的append方法；SQL的preparedStatement；</p></li><li><p>实现：</p><pre class="line-numbers language-none"><code class="language-none">public class TestObject &#123;    private ComponentA componentA;    private ComponentB componentB;&#125;public class ComponentA &#123;    public ComponentA(String a)&#123;        this.a &#x3D; a;    &#125;    private String a;&#125;public class ComponentB &#123;    public ComponentB(String b)&#123;        this.b &#x3D; b;    &#125;    private String b;&#125;public interface TestObjectBuilder &#123;    ComponentA builderComponentA();    ComponentB builderComponentB();&#125;public class TestObjectBuilderImpl implements TestObjectBuilder&#123;    @Override    public ComponentA builderComponentA() &#123;        System.out.println(&quot;构建组件A&quot;);        return new ComponentA(&quot;组件A&quot;);    &#125;    @Override    public ComponentB builderComponentB() &#123;        System.out.println(&quot;构建组件B&quot;);        return new ComponentB(&quot;组件B&quot;);    &#125;&#125;public interface TestObjectDirector &#123;    TestObject directorTestObject();&#125;public class TestObjectDirectorImpl implements TestObjectDirector&#123;    private TestObjectBuilder builder;    public TestObjectDirectorImpl(TestObjectBuilder builder)&#123;        this.builder &#x3D; builder;    &#125;    @Override    public TestObject directorTestObject() &#123;        ComponentA a &#x3D; builder.builderComponentA();        ComponentB b &#x3D; builder.builderComponentB();        TestObject t &#x3D; new TestObject();        t.setComponentA(a);        t.setComponentB(b);        return t;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式 - Prototype"></a>原型模式 - Prototype</h3><ol><li><p>作用：以某个对象为原型，复制出新的对象。新的对象具备原型对象的特点。解决产生一个对象需要繁琐的数据准备和访问权限的问题。一般和工厂方法模式一起使用</p></li><li><p>应用场景：Cloneable接口和clone方法</p></li><li><p>优点：效率高，避免了重新执行构造过程的步骤</p></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ShallowCloneObject implements Cloneable,Serializable&#123;    private String name;    private Date createTime;    public ShallowCloneObject(String name, Date createTime)&#123;        this.name &#x3D; name;        this.createTime &#x3D; createTime;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        return super.clone();    &#125;&#125;public class DeepCloneObject implements Cloneable&#123;    private String name;    private Date createTime;    public DeepCloneObject(String name, Date createTime)&#123;        this.name &#x3D; name;        this.createTime &#x3D; createTime;    &#125;    @Override    protected Object clone() throws CloneNotSupportedException &#123;        Object object &#x3D; super.clone();        DeepCloneObject deepCloneObject &#x3D; (DeepCloneObject) object;        deepCloneObject.createTime &#x3D; ((Date) this.createTime.clone());        return object;    &#125;&#125;public static void main(String[] args) throws CloneNotSupportedException &#123;    &#x2F;&#x2F; 浅克隆，克隆对象的时间字段与原型对象指向同一个date，修改后互相影响    System.out.println(&quot;浅克隆--------------------------&quot;);    Date date1 &#x3D; new Date();    ShallowCloneObject s &#x3D; new ShallowCloneObject(&quot;原型对象&quot;,date1);    System.out.println(s.getName() + s.getCreateTime());    ShallowCloneObject shallowCloneObject &#x3D; (ShallowCloneObject)s.clone();    System.out.println(shallowCloneObject.getName() + shallowCloneObject.getCreateTime());    shallowCloneObject.setName(&quot;克隆对象&quot;);    date1.setTime(1000000000000L);    System.out.println(s.getName() + s.getCreateTime());    System.out.println(shallowCloneObject.getName() + shallowCloneObject.getCreateTime());    &#x2F;&#x2F; 深复制    System.out.println(&quot;深复制--------------------------&quot;);    Date date2 &#x3D; new Date();    DeepCloneObject d &#x3D; new DeepCloneObject(&quot;原型对象&quot;,date2);    System.out.println(d.getName() + d.getCreateTime());    DeepCloneObject deepCloneObject &#x3D; (DeepCloneObject)d.clone();    System.out.println(deepCloneObject.getName() + deepCloneObject.getCreateTime());    deepCloneObject.setName(&quot;克隆对象&quot;);    date2.setTime(1000000000000L);    System.out.println(d.getName() + d.getCreateTime());    System.out.println(deepCloneObject.getName() + deepCloneObject.getCreateTime());&#125;public static void main(String[] args) throws IOException, ClassNotFoundException &#123;    &#x2F;&#x2F; 使用序列化和反序列化    Date date &#x3D; new Date();    ShallowCloneObject s &#x3D; new ShallowCloneObject(&quot;原型对象&quot;,date);    ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();    ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);    oos.writeObject(s);    byte[] bytes &#x3D; bos.toByteArray();    ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);    ObjectInputStream ois &#x3D; new ObjectInputStream(bis);    ShallowCloneObject deepCloneBySerialization &#x3D; (ShallowCloneObject)ois.readObject();    System.out.println(s.getName() + s.getCreateTime());    System.out.println(deepCloneBySerialization.getName() + deepCloneBySerialization.getCreateTime());    date.setTime(12121212121212L);    System.out.println(s.getName() + s.getCreateTime());    System.out.println(deepCloneBySerialization.getName() + deepCloneBySerialization.getCreateTime());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式-Adapter"></a>适配器模式-Adapter</h3><ol><li><p>描述：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的类可以一起工作</p></li><li><p>应用场景：旧系统升级改造；java.io.InputStreamReader(InputStream)；java.io.OutputStreamWriter(OutputStream);</p></li><li><p>角色：</p><ul><li>被适配的类 - Adaptee：持有既定方法，需要适配</li><li>适配器 - Adapter：使用Adaptee的方法满足Target需求</li><li>目标类 - Target：定义所需的方法</li></ul></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** 被适配的类* *&#x2F;public class Adaptee &#123;    public void request()&#123;        System.out.println(&quot;被适配的类提供客户端需要的功能&quot;);    &#125;&#125;&#x2F;** 适配器(类适配器方式)* *&#x2F;public class Adapter extends Adaptee implements Target&#123;    @Override    public void handleRequest() &#123;        super.request();    &#125;&#125;&#x2F;* * 适配器(对象适配器方式) * *&#x2F;public class Adapter2 implements Target&#123;    private Adaptee adaptee;    public Adapter2(Adaptee a)&#123;        super();        this.adaptee &#x3D; a;    &#125;    @Override    public void handleRequest() &#123;        adaptee.request();    &#125;&#125;public interface Target &#123;    void handleRequest();&#125;public class Client &#123;    public void test(Target t)&#123;        t.handleRequest();    &#125;    public static void main(String[] args) &#123;        &#x2F;&#x2F; 1. 类适配器        Client c1 &#x3D; new Client();        Target t1 &#x3D; new Adapter();        c1.test(t1);        &#x2F;&#x2F; 2. 对象组合适配器        Client c2 &#x3D; new Client();        Adaptee a &#x3D; new Adaptee();        Target t2 &#x3D; new Adapter2(a);        c2.test(t2);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 - Proxy"></a>代理模式 - Proxy</h3><ol><li><p>描述：通过代理控制对对象的访问，在调用某个对象方法前做前置处理，调用过后做后置处理。将统一的流程控制放在代理类中处理</p></li><li><p>应用场景：数据库连接池关闭处理；mybatis实现拦截器插件</p><ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用（RMI）</li><li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li></ul></li><li><p>角色：</p><ul><li>抽象的角色 - Subject：定义了使Proxy和RealSubject具有一致性的接口</li><li>代理人 - Proxy：实现了Subject接口，尽量代替真实角色处理请求，处理不了再转给RealSubject</li><li>真实角色 - RealSubject：实现了Subject接口，必要时处理请求</li></ul></li><li><p>实现方式：</p><ul><li><p>静态代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface AbstractRole &#123;    void step1();    void step2();    void step3();&#125;public class RealRole implements AbstractRole&#123;    @Override    public void step1() &#123;        System.out.println(&quot;真实角色-步骤1&quot;);    &#125;    @Override    public void step2() &#123;        System.out.println(&quot;真实角色-步骤2&quot;);    &#125;    @Override    public void step3() &#123;        System.out.println(&quot;真实角色-步骤3,代理角色没有的方法&quot;);    &#125;&#125;public class ProxyRole implements AbstractRole&#123;    AbstractRole abstractRole;    public ProxyRole(AbstractRole abstractRole)&#123;        super();        this.abstractRole &#x3D; abstractRole;    &#125;    @Override    public void step1() &#123;        System.out.println(&quot;代理角色-步骤1,代替真实角色执行&quot;);    &#125;    @Override    public void step2() &#123;        System.out.println(&quot;代理角色-步骤2,代替真实角色执行&quot;);    &#125;    @Override    public void step3() &#123;        abstractRole.step3();    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        AbstractRole realRole &#x3D; new RealRole();        AbstractRole proxyRole &#x3D; new ProxyRole(realRole);        proxyRole.step1();        proxyRole.step2();        proxyRole.step3();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>动态代理（JDK实现）</p><p>java.lang.reflect.Proxy：动态生成代理类和对象</p><p>java.lang.reflect.InvocationHandler：处理器接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface AbstractRole &#123;    void step1();    void step2();    void step3();&#125;public class RealRole implements AbstractRole &#123;    @Override    public void step1() &#123;        System.out.println(&quot;真实角色-步骤1&quot;);    &#125;    @Override    public void step2() &#123;        System.out.println(&quot;真实角色-步骤2&quot;);    &#125;    @Override    public void step3() &#123;        System.out.println(&quot;真实角色-步骤3,代理角色没有的方法&quot;);    &#125;&#125;public class AbstractRoleHandler implements InvocationHandler &#123;    AbstractRole abstractRole;    public AbstractRoleHandler(AbstractRole abstractRole)&#123;        this.abstractRole &#x3D; abstractRole;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        System.out.println(&quot;invoke流程控制&quot;);        Object object &#x3D; null;        System.out.println(&quot;真实角色方法执行前&quot;);        if(method.getName().equals(&quot;step3&quot;))&#123;            object &#x3D; method.invoke(abstractRole,args);        &#125;        System.out.println(&quot;真实角色方法执行后&quot;);        return object;    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        AbstractRole realRole &#x3D; new RealRole();        AbstractRoleHandler handler &#x3D; new AbstractRoleHandler(realRole);        AbstractRole proxyRole&#x3D; (AbstractRole)Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;AbstractRole.class&#125;,handler);        proxyRole.step3();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>比较：</p><p>动态代理的优点：抽象角色中声明的所有方法都被转移到调用处理器一个集中的方法中处理，可以更加灵活和统一地处理众多的方法</p></li></ol><h3 id="桥接模式-Bridge"><a href="#桥接模式-Bridge" class="headerlink" title="桥接模式 - Bridge"></a>桥接模式 - Bridge</h3><ol><li><p>描述：处理多层继承结构，处理多个维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立地扩展</p></li><li><p>应用场景：JDBC驱动程序</p></li><li><p>角色：</p></li><li><p>实现方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Veidoo1 &#123;    void veidoo1Method();&#125;public class Veidoo2 &#123;    protected Veidoo1 veidoo1;    public Veidoo2(Veidoo1 veidoo1)&#123;        this.veidoo1 &#x3D; veidoo1;    &#125;    public void veidoo2Method()&#123;        veidoo1.veidoo1Method();    &#125;&#125;public class Veidoo1Classify1 implements Veidoo1&#123;    @Override    public void veidoo1Method() &#123;        System.out.println(&quot;#####################&quot;);        System.out.println(&quot;Veidoo1Classify1&quot;);    &#125;&#125;public class Veidoo1Classify2 implements Veidoo1&#123;    @Override    public void veidoo1Method() &#123;        System.out.println(&quot;#####################&quot;);        System.out.println(&quot;Veidoo1Classify2&quot;);    &#125;&#125;public class Veidoo2Classify1 extends Veidoo2&#123;    public Veidoo2Classify1(Veidoo1 veidoo1)&#123;        super(veidoo1);    &#125;    @Override    public void veidoo2Method()&#123;        super.veidoo2Method();        System.out.println(&quot;Veidoo2Classify1&quot;);    &#125;&#125;public class Veidoo2Classify2 extends Veidoo2&#123;    public Veidoo2Classify2(Veidoo1 veidoo1)&#123;        super(veidoo1);    &#125;    @Override    public void veidoo2Method()&#123;        super.veidoo2Method();        System.out.println(&quot;Veidoo2Classify2&quot;);    &#125;&#125;public class Client &#123;    public static void main(String[] args) &#123;        Veidoo2 o1 &#x3D; new Veidoo2Classify1(new Veidoo1Classify1());        Veidoo2 o2 &#x3D; new Veidoo2Classify2(new Veidoo1Classify1());        Veidoo2 o3 &#x3D; new Veidoo2Classify1(new Veidoo1Classify2());        Veidoo2 o4 &#x3D; new Veidoo2Classify2(new Veidoo1Classify2());        o1.veidoo2Method();        o2.veidoo2Method();        o3.veidoo2Method();        o4.veidoo2Method();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="组合模式-Composite"><a href="#组合模式-Composite" class="headerlink" title="组合模式 - Composite"></a>组合模式 - Composite</h3><ol><li>描述：把部分和整体的关系用树形结构来表示，从而使客户端可以使用统一的方式处理部分对象和整体对象</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式（Group-Of-Four-23）【待补充】&quot;&gt;&lt;a href=&quot;#设计模式（Group-Of-Four-23）【待补充】&quot; class=&quot;headerlink&quot; title=&quot;设计模式（Group Of Four 23）【待补充】&quot;&gt;&lt;/a&gt;设计模式（</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA项目分层</title>
    <link href="https://silentspeechcoder.github.io/2021/07/13/java-xiang-mu-fen-ceng/"/>
    <id>https://silentspeechcoder.github.io/2021/07/13/java-xiang-mu-fen-ceng/</id>
    <published>2021-07-13T11:19:35.000Z</published>
    <updated>2022-07-21T04:46:44.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考阿里规范，优秀的-Java-项目代码该如何分层？"><a href="#参考阿里规范，优秀的-Java-项目代码该如何分层？" class="headerlink" title="参考阿里规范，优秀的 Java 项目代码该如何分层？"></a>参考阿里规范，优秀的 Java 项目代码该如何分层？</h1><p>来源：<a href="https://www.cnblogs.com/bainannan/p/14418277.html">https://www.cnblogs.com/bainannan/p/14418277.html</a></p><h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h3><p>说起应用分层，大部分人都会认为这个不是很简单嘛 就controller，service, mapper三层。看起来简单，很多人其实并没有把他们职责划分开，在很多代码中, controller做的逻辑比service还多, service往往当成透传了。<br>这其实是很多人开发代码都没有注意到的地方，反正功能也能用，至于放哪无所谓呗。这样往往造成后面代码无法复用，层级关系混乱，对后续代码的维护非常麻烦。<br>的确在这些人眼中分层只是一个形式，前辈们的代码这么写的，其他项目代码这么写的，那么我也这么跟着写。<br>但是在真正的团队开发中每个人的习惯都不同，写出来的代码必然带着自己的标签，有的人习惯controller写大量的业务逻辑，有的人习惯在service中之间调用远程服务，这样就导致了每个人的开发代码风格完全不同。<br>后续其他人修改的时候，一看，我靠这个人写的代码和我平常的习惯完全不同，修改的时候到底是按着自己以前的习惯改，还是跟着前辈们走，这又是个艰难的选择，选择一旦有偏差，你的后辈又维护你的代码的时候，恐怕就要骂人了。<br>所以一个好的应用分层需要具备以下几点:</p><ul><li>方便后续代码进行维护扩展。</li><li>分层的效果需要让整个团队都接受</li><li>各个层职责边界清晰<h3 id="2-如何进行分层"><a href="#2-如何进行分层" class="headerlink" title="2.如何进行分层"></a>2.如何进行分层</h3><h5 id="2-1阿里规范"><a href="#2-1阿里规范" class="headerlink" title="2.1阿里规范"></a>2.1阿里规范</h5>在阿里的编码规范中约束的分层如下:<img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_1.png" class="">开放接口层: 可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。<br>终端显示层: 各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。<br>Web 层: 主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。<br>Service 层: 相对具体的业务逻辑服务层。<br>Manager 层: 通用业务处理层，它有如下特征:1. 对第三方平台封装的层，预处理返回结果及转化异常信息;2. 对Service层通用能力的下沉，如缓存方案、中间件通用处理;3. 与DAO层交互，对多个DAO的组合复用。<br>DAO 层: 数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。<br>阿里巴巴规约中的分层比较清晰简单明了，但是描述得还是过于简单了，以及service层和manager层有很多同学还是有点分不清楚之间的关系，就导致了很多项目中根本没有Manager层的存在。下面介绍一下具体业务中应该如何实现分层<h5 id="2-2优化分层"><a href="#2-2优化分层" class="headerlink" title="2.2优化分层"></a>2.2优化分层</h5>从我们的业务开发中总结了一个较为的理想模型,这里要先说明一下由于我们的rpc框架选用的是thrift可能会比其他的一些rpc框架例如dubbo会多出一层,作用和controller层类似<img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_2.png" class=""></li></ul><p>1.最上层controller和TService是我们阿里分层规范里面的第一层: 轻业务逻辑，参数校验，异常兜底。通常这种接口可以轻易更换接口类型,所以业务逻辑必须要轻，甚至不做具体逻辑。<br>2.Service：业务层，复用性较低，这里推荐每一个controller方法都得对应一个service,不要把业务编排放在controller中去做，为什么呢？<br>如果我们把业务编排放在controller层去做的话，如果以后我们要接入thrift,我们这里又需要把业务编排在做一次，这样会导致我们每接入一个入口层这个代码都得重新复制一份如下图所示:</p><img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_3.png" class=""><p>这样大量的重复工作必定会导致我们开发效率下降，所以我们需要把业务编排逻辑都得放进service中去做:</p><img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_4.png" class=""><p>3.Mannager：可复用逻辑层。这里的Mannager可以是单个服务的，比如我们的cache,mq等等，当然也可以是复合的，当你需要调用多个Mannager的时候，这个可以合为一个Mannager，比如逻辑上的连表查询等。如果是httpMannager或rpcMannager需要在这一层做一些数据转换<br>4.DAO：数据库访问层。主要负责“操作数据库的某张表，映射到某个java对象”，dao应该只允许自己的Service访问，其他Service要访问我的数据必须通过对应的Service。</p><h3 id="3-分层领域模型的转换"><a href="#3-分层领域模型的转换" class="headerlink" title="3.分层领域模型的转换"></a>3.分层领域模型的转换</h3><p>在阿里巴巴编码规约中列举了下面几个领域模型规约:</p><ul><li>DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul><p>每一个层基本都自己对应的领域模型，这样就导致了有些人过于追求每一层都是用自己的领域模型，这样就导致了一个对象可能会出现3次甚至4次转换在一次请求中，当返回的时候同样也会出现3-4次转换，这样有可能一次完整的请求-返回会出现很多次对象转换。如果在开发中真的按照这么来，恐怕就别写其他的了，一天就光写这个重复无用的逻辑算了吧。<br>所以我们得采取一个折中的方案:</p><ol><li>允许Service/Manager可以操作数据领域模型，对于这个层级来说，本来自己做的工作也是做的是业务逻辑处理和数据组装。</li><li>Controller/TService层的领域模型不允许传入DAO层，这样就不符合职责划分了。</li><li>同理，不允许DAO层的数据传入到Controller/TService.</li></ol><img src="/2021/07/13/java-xiang-mu-fen-ceng/1626175175_5.png" class=""><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>总的来说业务分层对于代码规范是比较重要，决定着以后的代码是否可复用，是否职责清晰，边界清晰。<br>当然这种分层其实见仁见智, 团队中的所有人的分层习惯也不同，所以很难权衡出一个标准的准则，总的来说只要满足职责逻辑清晰，后续维护容易，就是好的分层。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;参考阿里规范，优秀的-Java-项目代码该如何分层？&quot;&gt;&lt;a href=&quot;#参考阿里规范，优秀的-Java-项目代码该如何分层？&quot; class=&quot;headerlink&quot; title=&quot;参考阿里规范，优秀的 Java 项目代码该如何分层？&quot;&gt;&lt;/a&gt;参考阿里规范，优</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL数据库知识点梳理</title>
    <link href="https://silentspeechcoder.github.io/2021/04/28/mysql-shu-ju-ku-zhi-shi-dian-shu-li/"/>
    <id>https://silentspeechcoder.github.io/2021/04/28/mysql-shu-ju-ku-zhi-shi-dian-shu-li/</id>
    <published>2021-04-28T03:27:30.000Z</published>
    <updated>2022-07-21T04:46:44.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库知识点梳理"><a href="#MySQL数据库知识点梳理" class="headerlink" title="MySQL数据库知识点梳理"></a>MySQL数据库知识点梳理</h1><h2 id="1-数据库基本命令"><a href="#1-数据库基本命令" class="headerlink" title="1. 数据库基本命令"></a>1. 数据库基本命令</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">MYSQL -UROOT -P123456 -- 连接数据库UPDATE MYSQL.USER SET AUTHENTICATION_STRING&#x3D;PASSWORD(&#39;123456&#39;) WHERE USER&#x3D;&#39;ROOT&#39; AND HOST&#x3D;&#39;LOCALHOST&#39;; -- 修改用户密码FLUSH PRIVILEGES; -- 刷新权限SHOW DATABASES; -- 查看所有数据库USE 数据库名; -- 切换数据库；SHOW TABLES; -- 查看数据库中所有表DESCRIBE 表名; -- 显示数据库中所有的表信息SHOW CREATE DATABASE &#96;库名&#96;; -- 查看创建数据库语句SHOW CREATE TABLE &#96;表名;&#96; -- 查看创建数据表语句DESC &#96;表名&#96;; -- 查看表结构EXIT; -- 退出连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE DATABASE [IF NOT EXISTS] 数据库名; -- 创建数据库DROP DATABASE [IF EXISTS] 数据库名; -- 删除数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-数据库的列类型"><a href="#3-数据库的列类型" class="headerlink" title="3. 数据库的列类型"></a>3. 数据库的列类型</h2><ul><li><p>数值</p><ul><li>tinyint 1字节</li><li>smallint 2字节</li><li>mediumint 3字节</li><li><strong>int 常用标准整数 4字节</strong></li><li>bigint 8字节</li><li>float 浮点数 4字节</li><li>double 浮点数 8字节</li><li>decimal 字符串形式的浮点数 用于金融计算</li></ul></li><li><p>字符串</p><ul><li>char 固定大小0~255</li><li><strong>varchar 可变字符串 0~65535</strong></li><li>tinytext 微型文本 2^8-1</li><li><strong>text 大文本 2^16-1</strong></li></ul></li><li><p>时间日期</p><ul><li>date YYYY-MM-DD 日期格式</li><li>time HH:mm:ss 时间格式</li><li><strong>datetime  YYYY-MM-DD HH:mm:ss 常用时间格式</strong></li><li>timestamp 时间戳</li><li>year 年份表示</li></ul></li><li><p>null</p></li></ul><h2 id="4-数据库字段属性"><a href="#4-数据库字段属性" class="headerlink" title="4. 数据库字段属性"></a>4. 数据库字段属性</h2><ul><li><p>Unsigned：</p><ul><li>无符号整数</li><li>声明该列不能为负数</li></ul></li><li><p>zerofill： 不足的位数0填充</p></li><li><p>自增： 设计唯一主键，类型必须为整数，可以自定义起始值和步长</p></li><li><p>非空：</p><ul><li>not null 不赋值会报错</li><li>null 不赋值默认为null</li></ul></li><li><p>default</p></li></ul><h2 id="5-数据表操作"><a href="#5-数据表操作" class="headerlink" title="5. 数据表操作"></a>5. 数据表操作</h2><ol><li><p>创建表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE [IF NOT EXISTS] &#96;表名&#96;( &#96;字段名&#96; 列类型 [属性] [索引] [注释],)[表类型][字符集][注释];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 RENAME AS 表名; -- 修改表名 ALTER TABLE 表名 ADD 字段名 列属性; -- 表增加字段ALTER TABLE 表名 MODIFY 字段名 列属性; -- 表修改约束ALTER TABLE 表名 CHANGE 字段名 字段名 列属性; -- 表字段重命名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除表字段</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE 表名 DROP 字段名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除表</p> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TABLE IF EXISTs 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="6-引擎"><a href="#6-引擎" class="headerlink" title="6. 引擎"></a>6. 引擎</h2><ul><li>INNODB（默认使用）：安全性高，事务处理。多表多用户操作<ul><li>支持事务</li><li>支持数据行锁定</li><li>支持外键约束</li><li>不支持全文索引</li><li>表空间大小：大</li></ul></li><li>MYISAM（较早版本使用）：节约空间，速度较快<ul><li>不支持事务</li><li>不支持数据行锁定</li><li>不支持外键约束</li><li>支持全文索引</li><li>表空间大小：小</li></ul></li></ul><h2 id="7-DML"><a href="#7-DML" class="headerlink" title="7. DML"></a>7. DML</h2><ul><li><p>插入</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO 表名([字段1,字段2]) values (&#39;值1&#39;,&#39;值2&#39;),(&#39;值1&#39;,&#39;值2&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE 表名 SET 字段1 &#x3D; 值1, 字段2 &#x3D; 值2, WHERE [条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELETE FROM 表名 WHERE [条件];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">TRUNCATE 表名; -- 清空表数据，重置自增列，不影响事务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询    </p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT [ALL|DISTINCT|DISTINCTROW|TOP]&#123;*|talbe.*|[table.]field1[AS alias1][,[table.]field2[AS alias2][,…]]&#125;FROM TABLE [AS 别名][LEFT | RIGHT | INNER join TABLE on …][WHERE…][GROUP BY…] -- 通过哪个字段分组[HAVING…] -- 过滤分组的记录必须满足的次要条件[ORDER BY 字段名 ASC|DESC][LIMIT 查询起始下标,数量];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT @@auto_increment_increment; -- 查询自增步长<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="8-七种JOIN"><a href="#8-七种JOIN" class="headerlink" title="8. 七种JOIN"></a>8. 七种JOIN</h2><img src="/2021/04/28/mysql-shu-ju-ku-zhi-shi-dian-shu-li/qizhongjon.png" class=""><h2 id="9-MYSQL常用函数"><a href="#9-MYSQL常用函数" class="headerlink" title="9. MYSQL常用函数"></a>9. MYSQL常用函数</h2><ul><li>数学运算函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ABS(-8)  -- 8，绝对值CEILING(9.4) -- 10，向上取整FLOOR(9.4) -- 9，向下取整RAND() -- 返回0-1的随机数SIGN() -- 返回一个数的符号，正数1，负数-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>字符串函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CHAR_LENGTH(&#39;字符串长度&#39;) -- 返回字符串长度CONCAT(&#39;拼接&#39;,&#39;多个&#39;,&#39;字符串&#39;) -- 拼接字符串INSERT(源字符串,位置,长度,插入字符串) -- 查找位置替换对应长度的字符串LOWER(字符串) -- 转小写UPPER(字符串) -- 转大写INSTR(字符串,子串) -- 返回第一次出现的子串的位置REPLACE(字符串,被替换,需替换) -- 替换指定字符串SUBSTR(字符串,截取起始位置,长度) -- 截取指定位置和长度的字符串REVERSE(字符串) -- 反转MD5(明文) -- MD5 加密<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>时间和日期函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CURRENT_DATE() -- 获取当前日期CURDATE() -- 获取当前日期NOW() -- 获取当前时间，时分秒LOCALTIME -- 获取本地时间，时分秒SYSDATE() -- 系统时间YEAR()MONTH()DAY()HOUR()MINUTE()SECOND()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>系统函数<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SYSTEM_USER()USER()VERSION() -- 获取版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>聚合函数</li></ul><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">COUNT() -- 统计数量，count(字段)忽略null，count(*),count(1)不会忽略nullSUM() -- 求和AVG() -- 求平均MAX() -- 求最大MIN() -- 求最小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-事务"><a href="#10-事务" class="headerlink" title="10. 事务"></a>10. 事务</h2><p>将一组SQL放在一个批次中去执行</p><ol><li><p>事务原则：ACID原则</p><ul><li><p>原子性：一起成功或一起失败</p></li><li><p>一致性：操作前后数据完整性最终一致</p></li><li><p>隔离性：多个用户同时操作，排除其他事务对本次事务的影响</p></li><li><p>持久性：事务结束后的数据不随外界原因导致丢失，事务未提交恢复原状，事务提交后持久化到数据库，一旦提交就不可逆</p></li></ul></li><li><p>事务的隔离级别</p><ul><li>脏读：一个事务读取到另一个事务未提交的数据</li><li>不可重复度：在一个事务内读取表中的某一行数据，多次读取结果不同</li><li>虚读（幻读）：在一个事务内读取到了别的事务插入的数据，导致前后读取不一致（比如多了一条）</li></ul></li><li><p>手动处理事务</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET autocommit &#x3D; 0; 关闭事务自动提交START TRANSACTION; -- 标记一个事务开始...COMMIT; -- 提交ROLLBACK; -- 回滚SET autocommit &#x3D; 1; 开启事务自动提交SAVEPOINT; -- 保存点ROLLBACK TO SAVEPOINT; -- 回滚到保存点RELEASE  SAVEPOINT; -- 撤销保存点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="11-索引"><a href="#11-索引" class="headerlink" title="11. 索引"></a>11. 索引</h2><p>索引（index）是帮助MYSQL高效获取数据的数据结构。</p><ol><li><p>索引的分类</p><ul><li>主键索引（PRIMARY KEY）唯一标识，不可重复，只能有一个列作为主键</li><li>唯一索引（UNIQUE KEY）避免重复的列出现，多个列都可以标识</li><li>常规索引（KEY/INDEX）默认的</li><li>全文索引（FULLTEXT）快速定位数据，在特定数据库引擎下才有</li></ul></li><li><p>索引的使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW INDEX FROM 表名; -- 显示所有索引信息ALTER TABLE 表名 ADD 索引类型 index 索引名(字段名); -- 添加索引CREATE INDEX 索引名 on 表名(字段名); -- 添加索引SELECT * FROM 表名 use index(索引名) WHERE ...; -- 提示SQL使用索引SELECT * FROM 表名 ignore index(索引名) WHERE ...; -- 提示SQL忽略使用索引SELECT * FROM 表名 force index(索引名) WHERE ...; -- 提示SQL必须使用索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>索引原则</p><ul><li>索引不是越多越好</li><li>不要对进程变动数据加索引</li><li>小数据量表不需要加索引</li><li>索引一般加在常用来查询的字段上</li><li>覆盖索引：查询使用了索引，并且需要返回的列在该索引中全部能找到，减少select *</li></ul></li><li><p>索引失效情况</p><ul><li>最左前缀原则：如果索引了多列（联合索引），查询从最左列开始，并且不跳过索引中的列。如果跳过某一列，索引将部分失效（后面的字段索引失效）。</li><li>联合索引中，出现范围查询（大于小于），范围查询右侧的列索引失效。业务允许的情况下使用大于等于、小于等于。</li><li>不要在索引列上进行运算，索引将失效。</li><li>字符串类型不加单引号，索引失效。</li><li>头部模糊匹配（%_），索引失效。尾部模糊匹配，索引不失效。</li><li>or分隔的条件，如果or两侧的条件有一侧无索引，则涉及的索引都不会被用到。</li><li>如果MySQL评估使用索引比全表扫描更慢，则不使用索引。</li></ul></li></ol><h2 id="12-用户管理"><a href="#12-用户管理" class="headerlink" title="12. 用户管理"></a>12. 用户管理</h2><p>用户表：mysql.user</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE USER 用户名 IDENTIFIED BY 密码; -- 创建用户SET PASSWORD &#x3D; PASSWORD(密码); -- 修改当前用户密码SET PASSWORD FOR 用户名 &#x3D; PASSWORD(密码); -- 修改指定用户密码RENAME USER 用户名 TO 新用户名; -- 重命名GRANT ALL PRIVILEGES ON 库.表 TO 用户; -- 用户授权所有权限SHOW GRANTS FOR 用户; -- 查询权限SHOW GRANTS FOR root@localhost; -- 查询权限REVOKE ALL PRIVILEGES ON 库.表 FROM 用户; -- 撤销权限DROP USER 用户名; -- 删除用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令行导出数据库：mysqldump -h主机名 -uroot -p密码 库名 表名1 表名2  &gt; 磁盘名/文件名</p><p>命令行导入数据库：source 磁盘名/文件名</p><h2 id="13-三大范式"><a href="#13-三大范式" class="headerlink" title="13. 三大范式"></a>13. 三大范式</h2><ul><li>第一范式（1NF）：数据库表的每一列都是不可分割的原子数据项</li><li>第二范式（2NF）：（满足第一范式）数据库表中的每一列都和主键相关，而不是只与主键的某一列相关</li><li>第三范式（3NF）：（满足第一范式和第二范式）数据库表的每一列都与主键直接相关，而不是间接相关</li></ul><h2 id="14-JDBC"><a href="#14-JDBC" class="headerlink" title="14. JDBC"></a>14. JDBC</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.jdbc.db;import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import com.mysql.jdbc.Statement;public class DBUTIL &#123;privatestatic final String URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;database&quot;;private static final String USERNAME &#x3D; &quot;root&quot;;private static final String PASSWORD &#x3D; &quot;password&quot;;public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;&#x2F;&#x2F; JDBC 的三要素文件，加载驱动，获取连接，&#x2F;&#x2F;1. 加载驱动程序Class.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;2. 获取数据库的连接 Connection 数据库连接对象Connection connection &#x3D; DriverManager.getConnection(URL,USERNAME,PASSWORD);&#x2F;&#x2F;3. 通过数据库的连接操作数据库，实现增删改查，Statement SQL执行对象Statement statement &#x3D; connection.createStatement();&#x2F;&#x2F;4. 返回 ResultSet 对象，编写 sql 语句，实现最简单的增删改查ResultSet resultSet &#x3D; statement.executeQuery(&quot;select username,password from user&quot;);&#x2F;&#x2F;打印数据while(resultSet.next()) &#123;&#x2F;&#x2F;返回字符串System.out.println(rs.getString(&quot;username&quot;) + rs.getString(&quot;password&quot;));&#125;        &#x2F;&#x2F;5. 释放连接        resultSet.close();        statement.close();        connection.close();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.thb.study3;import com.thb.study2.Utils.JdbcUtils;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.SQLException;public class Test03 &#123;    public static void main(String[] args) &#123;        Connection connection &#x3D; null;        PreparedStatement preparedStatement &#x3D; null;&#x2F;&#x2F; 预执行        try &#123;            connection &#x3D; JdbcUtils.getConnection();            connection.setAutoCommit(false);&#x2F;&#x2F; 关闭自动提交，开启事务            String sql &#x3D; &quot;update account set money&#x3D;money-100 where &#96;name&#96;&#x3D;&#39;A&#39;&quot;;            preparedStatement &#x3D; connection.prepareStatement(sql);            preparedStatement.executeUpdate();            String sql2 &#x3D; &quot;update account set money&#x3D;money+100 where &#96;name&#96;&#x3D;&#39;B&#39;&quot;;            preparedStatement &#x3D; connection.prepareStatement(sql2);            preparedStatement.executeUpdate();            connection.commit();            System.out.println(&quot;成功&quot;);        &#125; catch (SQLException e) &#123;            &#x2F;&#x2F;默认失败会回滚            connection.rollback();            e.printStackTrace();        &#125;finally &#123;            JdbcUtils.release(connection,preparedStatement,null);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-视图"><a href="#15-视图" class="headerlink" title="15. 视图"></a>15. 视图</h2><p>虚拟存在的表，数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。只保留sql的查询逻辑，不保存查询结果。</p><p>作用：1. 简化用户对数据的理解，也简化用户的操作。2. 设定视图用户的操作权限。3. 屏蔽真实表结构变化带来的影响</p><ul><li><p>创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CERATE VIEW 视图名 AS SELECT语句  [WITH[CASCADED | LOCAL] CHECK OPTION]; -- CASCADED 检查依赖的视图，LOCAL不检查依赖的视图<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW CREATE VIEW 视图名;SELECT * FROM 视图名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CERATE OR REPLACE VIEW 视图名 AS SELECT语句  [WITH[CASCADED | LOCAL] CHECK OPTION]; -- 方式一ALTER VIEW 视图名 AS SELECT语句 [WITH[CASCADED | LOCAL] CHECK OPTION]; -- 方式二<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP VIEW [IF EXISTS] 视图名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="16-存储过程"><a href="#16-存储过程" class="headerlink" title="16. 存储过程"></a>16. 存储过程</h2><p>数据库sql语言层面的代码封装和重用。</p><ul><li><p>创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELIMITER $$ -- 定义结束符CREATE PROCEDURE 存储过程名称([IN|OUT|INOUT 参数名 参数类型])BEGIN -- SQL语句END$$DELIMITER ; -- 重置结束符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>调用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CALL 名称([参数])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM INFORMATION_SCHEMA_ROUTINES WHERE ROUTINE_SCHEMA &#x3D; &#39;xxx&#39;;  -- 查询指定数据库的存储过程及状态信息SHOW CREATE PROCEDURE 存储过程名称;  -- 查询存储过程的定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP PROCEDURE [IF EXISTS] 存储过程名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>变量</p><ul><li><p>系统变量</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW [SESSION | GLOBAL] VARIABLES; -- 查看所有系统变量SELECT @@[SESSION | GLOBAL] 系统变量名; -- 查看指定变量的值SET [SESSION | GLOBAL] 系统变量名 &#x3D; 值; -- 设置系统变量SET @@[SESSION | GLOBAL] 系统变量名 &#x3D; 值; -- 设置系统变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>自定义变量</p><p>作用域：当前连接</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET @var_name  &#x3D; expr[,@var_name  &#x3D; expr]...; -- 赋值SET @var_name  :&#x3D; expr[,@var_name  :&#x3D; expr]...; -- 赋值SELECT @var_name  &#x3D; expr[,@var_name  &#x3D; expr]...; -- 赋值SELECT 字段名 INTO @var_name FROM 表名; -- 赋值SELECT @var_name; -- 使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>局部变量</p><p>作用域：BEGIN … END块;</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DECLARE 变量名 变量类型[DEFAULT]; -- 声明SET 变量名 &#x3D; 值; -- 赋值SET 变量名 :&#x3D; 值; -- 赋值SELECT 字段名 INTO 变量名 FROM 表名; -- 赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 判断-- ifIF 条件1 THEN...ELSEIF 条件2 THENELSE...END IF;-- caseCASE case_valueWHEN ... THEN ...ELSEEND CASE;-- 循环-- whileWHILE 条件 DO... sqlEND WHILE;-- repeatREPEAT... sqlUNTIL 条件END REPEAT;-- loop[begin_label:]LOOP...sqlEND LOOP [end_label];-- 游标DECLARE 游标名称 CURSOR FOR 查询语句; -- 声明游标OPEN 游标名称; -- 打开游标FETCH 游标名称 INTO 变量[,变量]; -- 获取游标记录-- handlerDECLARE handler_action HANDLER FOR condition_value[,condition_value]... statement; -- handler_actionCONTINUE; -- 继续执行程序EXIT; -- 终止程序-- condition_valueSQLSTATE sqlstate_value; -- 状态码SQLWARNING; -- 所有以01开头的SQLSTATE代码的缩写NOT FOUND; -- 所有以02开头的SQLSTATE代码的缩写SQLEXCEPTION; -- 所有没被SQLWARNING和NOT FOUND捕获<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>存储函数</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE FUNCTION 存储函数名称([参数列表])RETURNS TYPE [DETERMINISTIC | NO SQL |READS SQL DATA]BEGIN -- SQL语句RETURN ...;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="17-触发器"><a href="#17-触发器" class="headerlink" title="17. 触发器"></a>17. 触发器</h2><p>触发器是指与表有关的数据库对象，指在insert/update/delete之前或者之后，触发并执行触发器中定义的SQL集合。OLD，NEW指发生变化的记录内容</p><ul><li><p>创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER trigger_nameBEFORE|AFTER INSERT|UPDATE|DELETEON tb_name FOR EACH ROW -- 行级触发器BEGINtrigger_stmt;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW TRIGGERS;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TRIGGER [schema_name] trigger_name; -- 如果没有指定schema_name，默认当前数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="18-锁"><a href="#18-锁" class="headerlink" title="18. 锁"></a>18. 锁</h2><p>计算机协调多个进程或线程并发访问某一资源的机制。</p><ul><li><p>全局锁</p><p>对整个数据库实例加锁，加锁后处于只读状态。后续写操作将被阻塞。</p><p>使用场景：做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据完整性</p><pre class="line-numbers language-none"><code class="language-none">fush tables with read lock; -- 加全局锁unlock tables; -- 释放锁<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>表级锁</p><p>每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。</p><ul><li><p>表锁</p><p>加锁：lock tables 表名… read/write</p><p>释放锁：unlock tables / 客户端连接关闭</p><ul><li><p>表共享读锁（read lock）：阻塞写，不阻塞其他客户端的读</p></li><li><p>表独占写锁（write lock）：阻塞其他客户端的读写，不阻塞自己的读写</p></li></ul></li><li><p>元数据锁（meta data lock）</p><p>系统自动控制，无需显式使用。访问表时会自动加上，维护表元数据的数据一致性。在表上有未提交的事务时，不可以对元数据进行写入操作。避免了DML和DDL的冲突，保证读写的正确性。</p><p>增删改查时，加MDL读锁（共享），表结构变更时，加MDL写锁（排他）。</p></li><li><p>意向锁</p><p>使用场景：加表锁时需要检查每一行的行锁，为解决效率低的问题，使用意向锁减少检查。</p><ul><li><p>意向共享锁（IS）</p><p>与表锁共享锁（read）兼容，与表锁排他锁（write）互斥。</p></li><li><p>意向排他锁（IX）</p><p>与表锁共享锁（read）及表锁排他锁（write）都互斥，意向锁之间不互斥</p></li></ul></li></ul></li><li><p>行级锁</p><p>每次操作锁住对应表。锁定粒度小，发生锁冲突的概率最低，并发度最高。</p><p>通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p><ul><li><p>行锁（record lock）</p><p>锁定单个记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><ul><li><p>共享锁（S）：</p><p>允许一个事物去读一行，阻止其他事务获得相同数据集的排他锁。</p></li><li><p>排他锁（X）：</p><p>允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ul></li><li><p>间隙锁（gap lock）</p><p>锁定索引记录间隙（不含记录），确保索引记录间隙不变，防止其他事务insert产生幻读。在RR隔离级别下支持</p></li><li><p>临键锁（next-key-lock）</p><p>行锁和间隙锁的组合。在RR隔离级别下支持</p></li></ul></li></ul><h2 id="19-SQL性能分析"><a href="#19-SQL性能分析" class="headerlink" title="19. SQL性能分析"></a>19. SQL性能分析</h2><ul><li><p>SQL执行频率</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW GLOBAL STATUS LIKE &#39;Com_______)&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>开启慢查询日志</p></li></ul><p>​        /etc/my.cnf配置 ，配置完重启mysql</p><p>​        slow_query_log = 1 # 设置开启MYSQL慢查询日志</p><p>​        long_query_time = 2 # 设置SQL执行时间</p><ul><li><p>profile耗时详情</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show profiles;show profile [cpu] [for query query_id]; -- 耗时情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>expain</p><p>sql语句前加上explain/desc</p><ul><li><p>select _type</p><ul><li><p>SIMPLE 简单表，不使用表连接或者子查询</p></li><li><p>PRIMARY 主查询 外层的查询</p></li><li><p>UNION UNION中的第二个或者后面的查询语句</p></li><li><p>SUBQUERY SELECT / WHERE包含子查询</p></li></ul></li><li><p><strong>type</strong></p><p> ​    连接类型由好到差NULL（不访问表）、system（系统表）、const（主键或唯一索引）、eq_ref（唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配）、ref（非唯一性的索引）、range（使用索引返回一个范围中的行，如大于小于等情况）、index（用了索引但遍历索引树）、all（全表扫描）</p></li><li><p><strong>possible_key</strong> </p><p> 显示可能应用在这张表上的索引，一个或多个</p></li><li><p><strong>key</strong></p><p> 实际用到的索引，没有使用索引则为null</p></li><li><p><strong>key_len</strong></p><p> 索引中使用的字节数，索引字段最大可能长度（并非实际使用长度），长度越短越好</p></li><li><p>rows</p><p> mysql认为必须要执行查询的行数（不准确的估计值）</p></li><li><p>filtered</p><p> 表示返回结果行数占需读取行数的百分比，值越大越好</p></li><li><p>extra</p><ul><li>using index condition; 查找使用了索引，但是需要回表查询数据</li><li>using where;using index; 查找使用了索引，但是需要的数据都在索引列中能找到，不需要回表查询数据</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL数据库知识点梳理&quot;&gt;&lt;a href=&quot;#MySQL数据库知识点梳理&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库知识点梳理&quot;&gt;&lt;/a&gt;MySQL数据库知识点梳理&lt;/h1&gt;&lt;h2 id=&quot;1-数据库基本命令&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA集合</title>
    <link href="https://silentspeechcoder.github.io/2020/06/29/java-ji-he/"/>
    <id>https://silentspeechcoder.github.io/2020/06/29/java-ji-he/</id>
    <published>2020-06-29T14:11:06.000Z</published>
    <updated>2022-07-27T12:38:37.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA集合"><a href="#JAVA集合" class="headerlink" title="JAVA集合"></a>JAVA集合</h1><img src="/2020/06/29/java-ji-he/image-1.png" class=""><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>优点：是一种简单的线性序列，可以快速地访问数组元素，效率高。如果从效率和类型检查的角度讲，数组是最好的。</p></li><li><p>缺点：不灵活。容量需要事先定义好，不能随着需求变化扩容。</p></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>数据类型的参数化，数据类型的一个占位符（形式参数）。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>有序，可重复。</p><p>有三个实现类。ArrayList、LinkedList和Vector。</p><ul><li>在末尾添加一个元素：<code>boolean add(E e)</code></li><li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li><li>是否为空：<code>boolean isEmpty()</code></li><li>删除某个元素：<code>boolean remove(Object e)</code></li><li>清空：<code>void clear()</code></li><li>获取指定索引的元素：<code>E get(int index)</code></li><li>获取链表大小（包含元素的个数）：<code>int size()</code></li><li>添加一个list：<code>boolean addAll(Collection c)</code></li><li>删除与另一个list相同元素：<code>boolean removeAll(Collection c)</code></li><li>取交集：<code>boolean retainAll(Collection c)</code></li><li>是否包含另一个list：<code>boolean containsAll(Collection c)</code></li></ul><h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><p>用数组实现的存储。查询效率高，增删效率低，线程不安全。</p><p>通过数组扩容的方式实现不限制大小。</p><ul><li><p>指定索引添加或替换：<code>boolean set(int index, E e)</code></p></li><li><p>删除指定索引的元素：<code>E remove(int index)</code></p></li><li><p>是否存在某个元素，返回第一次出现的索引：<code>int indexOf(E e)</code></p></li><li><p>是否存在某个元素，返回最后一次出现的索引：<code>int indexOf(E e)</code></p></li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>用双向链表实现的存储。查询效率低，增删效率高，线程不安全。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>用数组实现的存储，效率低，线程安全。相关方法做了同步检查synchronized。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>存储键值对。键不可重复。</p><p>实现类HashMap、TreeMap、HashTable、Properties</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>线程不安全，效率高，允许key或者value为null，</p><ul><li>添加一个键值对：<code>Object put(Object key,Object value)</code></li><li>通过键查找值：<code>Object get(Object key)</code></li><li>是否为空：<code>boolean isEmpty()</code></li><li>删除指定键的键值对：<code>Object remove(Object key)</code></li><li>是否包含键对象：<code>boolean containsKey(Object key)</code></li><li>是否包含值对象：<code>boolean containsValue(Object value)</code></li><li>清空：<code>void clear()</code></li><li>获取Map大小（包含键值对的个数）：<code>int size()</code></li><li>添加一个Map中的所有对象：<code>void putAll(Map m)</code></li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>红黑二叉树的典型实现，排序key。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全，效率低，不允许key或者value为null。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>无序，不可重复。</p><ul><li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li><li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li><li>判断是否包含元素：<code>boolean contains(Object e)</code></li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>无序的，实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>有序的，实现了<code>SortedSet</code>接口。</p><h2 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h2><ul><li>迭代器遍历List</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();for (Iterator&lt;String&gt; it &#x3D; list.iterator(); it.hasNext(); ) &#123;     String s &#x3D; it.next();     System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器遍历Set</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();for (Iterator&lt;String&gt; it &#x3D; set.iterator(); it.hasNext(); ) &#123;     String s &#x3D; it.next();     System.out.println(s);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代器遍历Map</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();Set &lt;Entry&lt;String,String&gt;&gt; s &#x3D; map.entrySet();for (Iterator&lt;String&gt; it &#x3D; s.iterator(); it.hasNext(); ) &#123;     Entry e &#x3D; it.next();     System.out.println(e.getKey() + e.getValue());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();Set&lt;String&gt; s &#x3D; map.keySet();for(Iterator&lt;String&gt; it &#x3D; s.iterator(); it.hasNext(); )&#123;    String key &#x3D; it.next();    System.out.println(key + map.get(key));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><ul><li><p><code>void sort(List)</code>：对List元素升序排列</p></li><li><p><code>void shuffle(List)</code>：对List容器内元素随机排列</p></li><li><p><code>void reverse(List)</code>：对List元素逆转排列</p></li><li><p><code>void fill(List,Object)</code>：用一个特定的对象重写List容器</p></li><li><p><code>int binarySearch(List,Object)</code>：顺序折半查找</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA集合&quot;&gt;&lt;a href=&quot;#JAVA集合&quot; class=&quot;headerlink&quot; title=&quot;JAVA集合&quot;&gt;&lt;/a&gt;JAVA集合&lt;/h1&gt;&lt;img src=&quot;/2020/06/29/java-ji-he/image-1.png&quot; class=&quot;&quot;&gt;

</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://silentspeechcoder.github.io/2020/06/13/lambda/"/>
    <id>https://silentspeechcoder.github.io/2020/06/13/lambda/</id>
    <published>2020-06-13T11:52:30.000Z</published>
    <updated>2022-07-27T12:39:35.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>格式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">(param1,param2) -&gt; &#123;&#x2F;&#x2F; 重写方法的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用lambda必须有接口（函数式接口），接口中有且仅有一个抽象方法</li><li>使用lambda必须具有上下文推断</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;p&gt;格式&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-j</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA多线程</title>
    <link href="https://silentspeechcoder.github.io/2020/04/12/java-duo-xian-cheng/"/>
    <id>https://silentspeechcoder.github.io/2020/04/12/java-duo-xian-cheng/</id>
    <published>2020-04-12T04:56:11.000Z</published>
    <updated>2022-07-21T04:46:44.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-多线程"><a href="#JAVA-多线程" class="headerlink" title="JAVA 多线程"></a>JAVA 多线程</h1><h2 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h2><ul><li><p>并发：两个或多个事件在同一时间段发生（交替）</p></li><li><p>并行：两个或多个事件在同一时刻发生（同时）</p></li></ul><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>一个程序至少有一个进程，一个进程至少有一个线程。</p><ul><li><p>进程：一个内存中运行的应用程序。每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程。是系统运行程序的基本单位；系统运行一个程序是一个进程从创建、运行到消亡的过程。</p></li><li><p>线程：是进程中的一个执行单元，负责当前进程中的程序的执行。一个进程中至少有一个线程，可以有多个线程。</p></li></ul><p>和多线程相比，多进程的缺点在于：</p><ol><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ol><p>多进程的优点在于：</p><p>​    多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p><p>主线程：执行main方法的线程</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><ul><li><p>分时调度</p><p>所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间</p></li><li><p>抢占式调度（JAVA）</p><p>优先让优先级高的线程使用CPU，优先级相同随机选择一个线程</p></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多个现车个互不影响（在不同的栈空间）</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li><p>方式一</p><ol><li>创建一个Thread子类</li><li>在Thread类的子类中重写Thread类中的run方法，设置线程任务</li><li>创建Thread子类的对象</li><li>执行Thread类中的start方法（主线程与新线程）</li></ol></li><li><p>方式二</p><ol><li>创建一个实现Runnable接口的类</li><li>实现run方法</li><li>创建实现类的对象</li><li>创建Thread类对象，构造方法中传递Runnable接口的实现类对象</li><li>执行Thread类中的start方法（主线程与新线程）</li></ol></li></ul><p>方式二避免了单继承的局限性，增强了程序的扩展性，降低了耦合性</p><ul><li><p>匿名内部类实现线程创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; Thread子类实现new Thread()&#123;    @Override    public void run()&#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;.start();&#x2F;&#x2F; Runnable接口实现new Thread(new Runnable()&#123;    @Override    public void run()&#123;        System.out.println(Thread.currentThread().getName());    &#125;&#125;).start();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获取当前线程名称Thread.currentThread().getName(); &#x2F;&#x2F; 获取线程名称Thread t1 &#x3D; new Thread();t1.getName();&#x2F;&#x2F; 设置线程名称t1.setName(&quot;线程1&quot;);&#x2F;&#x2F; 当前线程暂停执行指定的毫秒数Thread.sleep(1000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多个线程共享同一数据</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ol><li><p>同步代码块</p><p>线程执行到synchronized会检查是否有锁对象，如果有进入同步中执行，如果没有就阻塞等待。同步执行完归还同步锁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">synchronized(同步锁对象)&#123;&#x2F;&#x2F; 需要同步的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>同步方法</p><ul><li>方法上添加synchronized，同步锁对象是this</li><li>静态同步方法的锁对象是类.class</li></ul></li><li><p>锁机制（Lock锁）更先进</p><p>在成员位置创建一个ReentrantLock（实现了Lock接口）对象，在出现安全问题的代码前调用lock获取锁，在出现安全问题的代码后调用unlock释放锁。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Lock l &#x3D; new Lock();l.lock();&#x2F;&#x2F; 线程安全问题代码l.unlock(); &#x2F;&#x2F; 一般放在try catch后的finally中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li>New：新创建的线程，尚未执行</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；具有CPU的执行资格，等待CPU空闲</li><li>Waiting：运行中的线程，因为某些操作在等待中；通过<code>notify()</code>唤醒</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；放弃CPU的执行资格，CPU空闲也不执行；休眠结束唤醒</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕</li></ul><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><h2 id="线程通信-等待唤醒机制"><a href="#线程通信-等待唤醒机制" class="headerlink" title="线程通信-等待唤醒机制"></a>线程通信-等待唤醒机制</h2><p>等待唤醒机制使各线程有效利用资源，解决线程间处理同一个资源的问题</p><ol><li><p>wait</p><p>线程不再活动参与调度，进入wait set中，这是线程状态是WAITING。等待其他线程执行notify后从wait set中释放出来，重新进入调度队列中</p></li><li><p>notify</p><p>选取所通知对象的wait set中的一个线程释放</p></li><li><p>notifyAll</p><p>释放所通知对象的wait set中的所有线程</p></li></ol><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li><li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li><li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li><li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li><li>已唤醒的线程还需要重新获得锁后才能继续执行。</li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使线程可以复用，减少了反复创建和销毁线程的时间</p><p>线程池是一个容器。当程序第一次启动时，创建多个线程保存在集合中。没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p><ul><li>降低资源消耗</li><li>提高响应速度</li><li>提高线程可管理性</li></ul><p>java.util.concurrent.Executors:线程池的工厂类</p><ul><li><p>创建线程池</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">ExecutorService es &#x3D; Executors.newFixedThreadPool(2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>submit执行线程任务</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">es.submit(new Runnable() &#123;    @Override    public void run() &#123;    System.out.println(Thread.currentThread().getName());    &#125;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>销毁线程池（不建议使用）</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java">es.shutdown();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA-多线程&quot;&gt;&lt;a href=&quot;#JAVA-多线程&quot; class=&quot;headerlink&quot; title=&quot;JAVA 多线程&quot;&gt;&lt;/a&gt;JAVA 多线程&lt;/h1&gt;&lt;h2 id=&quot;并发并行&quot;&gt;&lt;a href=&quot;#并发并行&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JAVA基础梳理（持续补充）</title>
    <link href="https://silentspeechcoder.github.io/2019/07/12/java-ji-chu-shu-li/"/>
    <id>https://silentspeechcoder.github.io/2019/07/12/java-ji-chu-shu-li/</id>
    <published>2019-07-12T02:38:26.000Z</published>
    <updated>2022-07-21T04:46:44.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础梳理（持续补充）"><a href="#JAVA基础梳理（持续补充）" class="headerlink" title="JAVA基础梳理（持续补充）"></a>JAVA基础梳理（持续补充）</h1><h2 id="1-JVM、JRE、JDK"><a href="#1-JVM、JRE、JDK" class="headerlink" title="1. JVM、JRE、JDK"></a>1. JVM、JRE、JDK</h2><ul><li>JVM：虚拟的用于执行bytecode字节码的虚拟计算机</li><li>JRE：JAVA运行环境，包含JAVA虚拟机、库函数、运行JAVA应用程序所必须的文件</li><li>JDK：JAVA工具包，包含JRE，以及增加编译器和调试器等用于程序开发的文件</li></ul><img src="/2019/07/12/java-ji-chu-shu-li/image-1.png" class=""><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><ul><li><p>局部变量</p><p>方法内部的变量。生命周期从声明到方法执行结束</p></li><li><p>成员变量</p><p>方法外部、类内部的变量。生命周期伴随对象</p></li><li><p>静态变量</p><p>使用static定义。从属于类，生命周期伴随类的加载到卸载。</p><p>静态字段属于所有对象“共享”的变量，实际上是属于类的变量，无论修改哪个对象的静态变量，效果都是一样的：所有实例的静态变量都被修改了。所以一般访问静态变量用 类名.静态变量</p></li></ul><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h2><ul><li><p>基本数据类型</p><ul><li><p>整数类型（byte 1字节=8位 范围-2^7~2^7-1，short 2字节，int 4字节，long 8字节）</p></li><li><p>浮点类型（float 4字节 范围-3.403E38<del>3.403E38，double 8字节 范围-1.798E308</del>1.798E308）</p></li><li><p>字符型（char 2字节）</p></li><li><p>布尔型（boolean 1位）</p></li></ul></li><li><p>引用数据类型（4字节，存放引用地址）</p><p>class，inerface，array</p></li></ul><h2 id="4-方法"><a href="#4-方法" class="headerlink" title="4. 方法"></a>4. 方法</h2><ul><li><p>静态方法：static修饰的方法属于<code>class</code>而不属于对象。静态方法内部，无法访问<code>this</code>变量，也无法访问对象的成员变量，它只能访问静态变量和其他静态方法。常用于工具类</p></li><li><p>方法重载（override）：方法名相同，参数不同，构成重载</p></li><li><p>方法重写（override）：子类通过重写父类的方法，替换父类的行为</p><ul><li>方法名、形参列表相同</li><li>返回值类型和异常类型，子类小于等于父类</li><li>访问权限，子类大于父类</li></ul></li></ul><h2 id="5-类与对象"><a href="#5-类与对象" class="headerlink" title="5. 类与对象"></a>5. 类与对象</h2><p>类可以看作对象的模板</p><ul><li><p>构造方法（constructor）：用于创建这个类的对象</p><ol><li>通过new关键字调用</li><li>构造器虽然有返回值，但是不能定义返回值类型，不能在构造器内使用return返回某个值</li><li>如果我们没有定义构造器，无参的构造方法由系统自动生成</li><li>方法名与类名保持一致</li><li>构造方法执行的第一行代码总是super();</li></ol></li><li><p>对象转型</p><ul><li><p>向上转型：父类引用指向子类对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Father f &#x3D; new Child();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>强制向下转型</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Child c &#x3D; (Child) f;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><h2 id="6-内存分析"><a href="#6-内存分析" class="headerlink" title="6. 内存分析"></a>6. 内存分析</h2><p>java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area</p><ul><li><p>栈：</p><ol><li>栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（用于存储局部变量、操作数、方法出口等）</li><li>JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）</li><li>栈属于线程私有，不能实现线程间的共享</li><li>栈的存储特性是先进后出、后进先出</li><li>栈由系统自动分配，速度快。栈是连续的存储空间</li></ol></li><li><p>堆：</p><ol><li>堆用于存储创建好的对象和数组</li><li>JVM只有一个堆，被所有线程共享</li><li>堆是一个不连续的存储空间，分配灵活，速度慢</li></ol></li><li><p>方法区（静态区）：</p><ol><li>JVM只有一个方法区，被所有线程共享</li><li>方法区实际也是堆，只用于存储类、常量等相关信息</li><li>用于存放唯一或不变的内容（类信息、静态变量、字符串常量等）</li></ol></li></ul><img src="/2019/07/12/java-ji-chu-shu-li/image-2.png" class=""><h2 id="7-继承（extends）"><a href="#7-继承（extends）" class="headerlink" title="7. 继承（extends）"></a>7. 继承（extends）</h2><ul><li>Java只有单继承（接口有多继承）</li><li>子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法和私有的属性和方法）</li><li>没有extends时，则继承java.lang.Object</li><li>super 直接父类对象的引用，用于访问父类中被子类覆盖的方法或属性</li></ul><h2 id="8-封装"><a href="#8-封装" class="headerlink" title="8. 封装"></a>8. 封装</h2><p>程序设计要求高内聚低耦合</p><ul><li><p>优点：</p><ol><li>提高代码安全性</li><li>提高代码的复用性</li><li>高内聚指类的内部数据操作细节已经完成，不允许外部干涉</li><li>低耦合是仅暴露少量的方法给外部使用，尽量方便外部调用</li></ol></li><li><p>访问权限：</p><ol><li>private 私有权限，只有自己的类能访问</li><li>default 默认权限，只有同一个包的类能访问</li><li>protected 受保护权限，可以被同一个包的类及其他包的子类访问</li><li>public 公开权限，可以被该项目的所有包中的所有类访问</li></ol></li><li><p>JavaBean：</p><ul><li><p>若干<code>private</code>实例字段</p></li><li><p>通过<code>public</code>  get/set方法来读写实例字段</p></li><li><p>枚举一个JavaBean的所有属性，可以使用Java核心库提供的Introspector（注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的。）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BeanInfo info &#x3D; Introspector.getBeanInfo(类名.class);PropertyDescriptor pd  &#x3D; info.getPropertyDescriptors()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="9-多态（Polymorphic）"><a href="#9-多态（Polymorphic）" class="headerlink" title="9. 多态（Polymorphic）"></a>9. 多态（Polymorphic）</h2><p>同一个方法调用，由于对象不同可能会有不同的行为</p><ul><li>是方法的多态，与属性无关（多态与属性无关）</li><li>多态的三个必要条件：继承，方法重写，父类引用指向子类对象</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法</li></ul><h2 id="10-final关键字"><a href="#10-final关键字" class="headerlink" title="10. final关键字"></a>10. final关键字</h2><ul><li>修饰变量：被final修饰的变量不可改变，必须在创建对象时初始化，不能重新赋值</li><li>修饰方法：被final修饰的方法不可被子类重写，但是可以被重载</li><li>修饰类：被final修饰的类不能被继承（Math、String）</li></ul><h2 id="11-数组"><a href="#11-数组" class="headerlink" title="11. 数组"></a>11. 数组</h2><ul><li>长度是确定的。一旦被创建，大小不可改变</li><li>元素是相同数据类型</li><li>数组类型可以使任意数据类型。数组本身是引用类型</li></ul><p>声明：声明的时候没有实例化任何对象，只有在实例化对象时JVM才分配空间。声明时数据没有真正被创建</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 声明：栈内存Type[] arr_name;Type arr_name[];&#x2F;&#x2F; 声明并实例化。分配空间：堆内存Type[] arr_name &#x3D; new Type[size];Type arr_name[] &#x3D; new Type[size];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="12-抽象方法抽象类（abstract）"><a href="#12-抽象方法抽象类（abstract）" class="headerlink" title="12. 抽象方法抽象类（abstract）"></a>12. 抽象方法抽象类（abstract）</h2><ul><li><p>抽象方法</p><p>使用abstract修饰的方法，没有方法体只有声明，定义子类具体实现的规范</p></li><li><p>抽象类</p><p>包含抽象方法的类（只能定义成抽象类）。不能实例化，只能用来被继承，使子类更加通用</p></li></ul><h2 id="13-接口（interface）"><a href="#13-接口（interface）" class="headerlink" title="13. 接口（interface）"></a>13. 接口（interface）</h2><p>接口的所有方法都是抽象方法</p><ul><li>访问修饰符只能是public或默认</li><li>可以多继承接口，extends</li><li>接口中的属性只能是常量，public static final 修饰（默认）</li><li>方法 public abstract修饰（默认）</li><li>子类通过implements实现接口规范，并且要实现接口中所有方法（public）</li><li>不能实例化</li></ul><h2 id="14-内部类（Inner-Class）"><a href="#14-内部类（Inner-Class）" class="headerlink" title="14. 内部类（Inner Class）"></a>14. 内部类（Inner Class）</h2><ul><li><p>成员内部类</p><p>  可以使用private、default、protected、public修饰，类文件：外部类$内部类.class</p><ul><li>非静态内部类<ol><li>非静态内部类寄存在一个外部类里，非静态内部类对象一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象</li><li>非静态内部类可以直接访问外部类的成员，但外部类不能直接访问非静态内部类成员</li><li>非静态内部类不能有静态方法。静态属性和静态代码块</li><li>外部类的静态方法。静态代码块不能访问非静态内部类，不能使用非静态内部类定义变量、创建实例</li></ol></li><li>静态内部类<ol><li>静态内部类存在时，不一定存在对应的外部类对象。静态内部类的实例方法不能直接访问外部类的实例方法</li><li>静态内部类看做外部类的一个静态成员。外部类方法中可以通过 静态内部类.成员名 访问静态内部类的静态成员，通过 new 静态内部类（）常见静态内部类的实例</li></ol></li></ul></li><li><p>匿名内部类</p><p>  适用于一次性使用的类</p><p>  没有访问修饰符</p><p>  没有构造方法和类名</p>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">new 构造器&#x2F;接口() &#123;    &#x2F;&#x2F; 实现必要的抽象方法...&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>局部内部类</p></li></ul><h2 id="15-常用类"><a href="#15-常用类" class="headerlink" title="15. 常用类"></a>15. 常用类</h2><ul><li><p>包装类</p><p>Byte、Boolean、Short、Character、Integer、Long、Float、Double</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 基本类型转换为包装类Integer i1 &#x3D; new Integer(100); Integer i2 &#x3D; Integer.valueOf(100);&#x2F;&#x2F; 包装类转换为基本类型int i3 &#x3D; i1.intValue();&#x2F;&#x2F; 字符串转换为IntegerInteger i4 &#x3D; Integer.parseInt(&quot;100&quot;);Integer i5 &#x3D; new Integer(&quot;100&quot;);&#x2F;&#x2F; Integer转换为字符串String s1 &#x3D; i4.toString();&#x2F;&#x2F; int类型最大值Integer.MAX_VALUE;&#x2F;&#x2F; 自动装箱Integer i &#x3D;100;&#x2F;&#x2F; 自动拆箱int j &#x3D; i;&#x2F;&#x2F; 编译通过但是空指针异常Integer i &#x3D; null;int j &#x3D; i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>String类</p><p>可变字符序列：StringBuilder不安全但效率高，StringBuffer安全但效率低（一般用StringBuilder）</p></li><li><p>Date类</p><p>时间戳：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">long now &#x3D;  System.currentTimeMillis();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>DateFormat类：时间对象和指定格式的字符串相互转化。抽象类，一般需要SimpleDateFormat类实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Dateformat df &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;);String str &#x3D; df.format(new Date(4000000));Date date &#x3D; df.parse(&quot;2020-05-21 13:14:15&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>File类</p><p>java.io.file</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">File f &#x3D; new File(&quot;文件路径&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="16-枚举"><a href="#16-枚举" class="headerlink" title="16. 枚举"></a>16. 枚举</h2><p>enum，本质是类，public static final 修饰</p><h2 id="17-异常"><a href="#17-异常" class="headerlink" title="17. 异常"></a>17. 异常</h2><p>java.lang.throwable，两个子类Error和Exception</p><img src="/2019/07/12/java-ji-chu-shu-li/image-3.png" class=""><ul><li>catch方法。toString()，显示异常的类名和产生异常的原因</li><li>catch方法。getMessage()，只显示产生异常的原因，不显示类名</li><li>catch方法。printStackTrace()，跟踪异常事件发生时的堆栈内容</li><li>finally语句可选，如果有的话，则不管是否发生异常都会执行</li><li>try catch中存在return，执行完finally语句再通过return语句退出</li><li>自定义异常，继承exception类</li></ul><p>Exception<br>│<br>├─ RuntimeException<br>│  │<br>│  ├─ NullPointerException<br>│  │<br>│  ├─ IndexOutOfBoundsException<br>│  │<br>│  ├─ SecurityException<br>│  │<br>│  └─ IllegalArgumentException<br>│     │<br>│     └─ NumberFormatException<br>│<br>├─ IOException<br>│  │<br>│  ├─ UnsupportedCharsetException<br>│  │<br>│  ├─ FileNotFoundException<br>│  │<br>│  └─ SocketException<br>│<br>├─ ParseException<br>│<br>├─ GeneralSecurityException<br>│<br>├─ SQLException<br>│<br>└─ TimeoutException</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA基础梳理（持续补充）&quot;&gt;&lt;a href=&quot;#JAVA基础梳理（持续补充）&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础梳理（持续补充）&quot;&gt;&lt;/a&gt;JAVA基础梳理（持续补充）&lt;/h1&gt;&lt;h2 id=&quot;1-JVM、JRE、JDK&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux shell脚本报错</title>
    <link href="https://silentspeechcoder.github.io/2019/01/08/shell-jiao-ben-bao-cuo/"/>
    <id>https://silentspeechcoder.github.io/2019/01/08/shell-jiao-ben-bao-cuo/</id>
    <published>2019-01-08T03:26:57.000Z</published>
    <updated>2022-07-21T04:46:44.658Z</updated>
    
    <content type="html"><![CDATA[<p>shell脚本报错 “syntax error near unexpected token `fi’”</p><p>1.cat -v mysqlmonitor.sh命令查看代码<br>2.linux里面查看后自动在换行符后面带上了^M的标识<br>3.用vim打开文件，在命令行模式下输入:set ff=unix</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;shell脚本报错 “syntax error near unexpected token `fi’”&lt;/p&gt;
&lt;p&gt;1.cat -v mysqlmonitor.sh命令查看代码&lt;br&gt;2.linux里面查看后自动在换行符后面带上了^M的标识&lt;br&gt;3.用vim打开文件，在</summary>
      
    
    
    
    
  </entry>
  
</feed>
